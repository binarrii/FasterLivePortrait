<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Stream</title>
</head>
<body>
<video id="video" width="640" height="480" controls autoplay muted></video>
<video id="player" width="640" height="480" controls autoplay muted></video>
<canvas id="canvas" style="display: none;"></canvas>
<script>
    navigator.mediaDevices.getUserMedia({video: true})
        .then((stream) => {
            // 将视频流显示在视频元素中
            const video = document.querySelector('video');
            video.srcObject = stream;

            // 获取视频轨道
            const videoTrack = stream.getVideoTracks()[0];
            const imageCapture = new ImageCapture(videoTrack);

            // 找到 canvas 元素或创建一个
            const canvas = document.getElementById('canvas');

            // 定期抓取帧并发送到 WebSocket
            const captureFrame = () => {
                imageCapture.grabFrame()
                    .then((imageBitmap) => {
                        try {
                            // 将帧转换为Blob格式发送
                            canvas.width = imageBitmap.width;
                            canvas.height = imageBitmap.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(imageBitmap, 0, 0);
                            canvas.toBlob((blob) => {
                                if (socket.readyState === WebSocket.OPEN) {
                                    socket.send(blob);
                                }
                            });
                        } catch (e) {
                            console.log(e);
                        }
                    })
                    .catch((err) => {
                        if (err) console.error(err)
                        // else console.error("unknown error")
                    });
            };

            setInterval(captureFrame, 25);
        })
        .catch((err) => {
            console.error("Error accessing webcam: ", err);
        });

    const player = document.getElementById('player');
    const mediaSource = new MediaSource();
    player.src = URL.createObjectURL(mediaSource);
    let videoSourceBuffer;
    mediaSource.addEventListener('sourceopen', function () {
        // videoSourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.4d002a"');
        videoSourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs=vp9');
    }, false);
    mediaSource.addEventListener('sourceended', function (e) {
        console.warn('MediaSource ended');
    }, false);
    mediaSource.addEventListener('sourceclosed', function (e) {
        console.warn('MediaSource closed');
    }, false);

    const appendToSourceBuffer = (blob) => {
        // 将队列中的数据块追加到 SourceBuffer
        blob.arrayBuffer()
            .then((buf) => {
                if (videoSourceBuffer && !videoSourceBuffer.updating) {
                    videoSourceBuffer.appendBuffer(buf);
                }
            })
            .catch((err) => {
                if (err) console.error(err);
            });
    };

    const socket = new WebSocket(window.location.href.replace('http', 'ws') + 'ws');

    socket.onmessage = (event) => {
        console.log(`frame received: ${event.data.size}`);
        if (mediaSource.readyState !== 'open') return;
        if (videoSourceBuffer && !videoSourceBuffer.updating) {
            appendToSourceBuffer(event.data);
        }
    };

    socket.onopen = function () {
        console.log('WebSocket connection established');
    };

    socket.onclose = function () {
        console.log('WebSocket connection closed');
    };

    socket.onerror = function (error) {
        console.error('WebSocket error:', error);
    };
</script>
</body>
</html>
