<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Stream</title>
</head>
<body>
<video id="video" width="640" height="480" autoplay></video>
<video id="player" controls autoplay></video>
<canvas id="canvas" style="display: none;"></canvas>
<script>
    const video = document.getElementById('video');
    const socket = new WebSocket('ws://192.168.1.73:8080/ws');

    navigator.mediaDevices.getUserMedia({video: true})
        .then((stream) => {
            // 将视频流显示在视频元素中
            const video = document.querySelector('video');
            video.srcObject = stream;

            // 获取视频轨道
            const videoTrack = stream.getVideoTracks()[0];
            const imageCapture = new ImageCapture(videoTrack);

            // 找到 canvas 元素或创建一个
            const canvas = document.getElementById('canvas');

            // 定期抓取帧并发送到 WebSocket
            const captureFrame = () => {
                imageCapture.grabFrame().then((imageBitmap) => {
                    // 将帧转换为Blob格式发送
                    canvas.width = imageBitmap.width;
                    canvas.height = imageBitmap.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(imageBitmap, 0, 0);
                    canvas.toBlob((blob) => {
                        if (socket.readyState === WebSocket.OPEN) {
                            socket.send(blob);
                        }
                    });
                });
            };

            setInterval(captureFrame, 25);
        })
        .catch((err) => {
            console.error("Error accessing webcam: ", err);
        });

    const player = document.getElementById('player');
    const mediaSource = new MediaSource();
    player.src = URL.createObjectURL(mediaSource);

    let videoSourceBuffer;
    const queue = [];
    const appendToSourceBuffer = function () {
        if (queue.length > 0 && !videoSourceBuffer.updating) {
            // 将队列中的数据块追加到 SourceBuffer
            const chunk = queue.shift();
            videoSourceBuffer.appendBuffer(chunk);
        }
    }

    socket.onmessage = (event) => {
        // 当接收到WebSocket数据时，将其加入队列
        queue.push(event.data);
        if (videoSourceBuffer && !videoSourceBuffer.updating) {
            appendToSourceBuffer();
        }
    };

    mediaSource.addEventListener('sourceopen', () => {
        // 创建 SourceBuffer，指定视频格式
        videoSourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
        if (queue.length > 0) {
            appendToSourceBuffer();
        }
    });

    socket.onopen = function () {
        console.log('WebSocket connection established');
    };

    socket.onclose = function () {
        console.log('WebSocket connection closed');
    };

    socket.onerror = function (error) {
        console.error('WebSocket error:', error);
    };
</script>
</body>
</html>
